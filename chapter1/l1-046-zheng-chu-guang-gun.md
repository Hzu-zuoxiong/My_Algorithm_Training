## L1-046. 整除光棍 {#l1-046-整除光棍}

[L1-046. 整除光棍](https://www.patest.cn/contests/gplt/L1-046)

这里所谓的“光棍”，并不是指单身汪啦~ 说的是全部由1组成的数字，比如1、11、111、1111等。传说任何一个光棍都能被一个不以5结尾的奇数整除。比如，111111就可以被13整除。 现在，你的程序要读入一个整数x，这个整数一定是奇数并且不以5结尾。然后，经过计算，输出两个数字：第一个数字s，表示x乘以s是一个光棍，第二个数字n是这个光棍的位数。这样的解当然不是唯一的,题目要求你输出最小的解。+

提示：一个显然的办法是逐渐增加光棍的位数，直到可以整除x为止。但难点在于，s可能是个非常大的数 —— 比如，程序输入31，那么就输出3584229390681和15，因为31乘以3584229390681的结果是111111111111111，一共15个1。

输入格式：  
输入在一行中给出一个不以5结尾的正奇数x（&lt; 1000）。

输出格式：  
在一行中输出相应的最小的s和n，其间以1个空格分隔。

输入样例：  
31  
输出样例：  
3584229390681 15

---

## 题解： {#题解}

此题为模拟除法，从1开始，每次在其后增加一个1，直到与x求模的余数为0则说明可以整除。每次进行除法运算后所得的得数保存在char数组中。数组的长度即为光棍数的位数。

---

### AC代码： {#ac代码：}

```cpp
#include<iostream>
#include<cstdio>
#include<string>
#include<cstring>
#include<cfloat>
#include<queue>
#include<stack>
#include<vector>

using namespace std;

char str[1005];

int main() {

    int n;
    cin >> n;
    int p = 0;
    int now = 1;
    int len = 0;
    while(1) {

        if(p || now / n) {
            //保存得数； 
            str[p++] = '0' + now / n;
        }
        len++;

        //保存余数； 
        now %= n;
        if(!now) {
            str[p] = 0;
            cout << str << " " << len << endl;
            break;
        }

        //每次增加一位+1； 
        now = now * 10 + 1;
    }
}
```



