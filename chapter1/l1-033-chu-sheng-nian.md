### L1-033. 出生年 {#l1-033-出生年}

题目链接：[L1-033. 出生年](https://www.patest.cn/contests/gplt/L1-033)

![](http://nos.patest.cn/nv_onaplraw3au.JPG)  
  以上是新浪微博中一奇葩贴：“我出生于1988年，直到25岁才遇到4个数字都不相同的年份。”也就是说，直到2013年才达到“4个数字都不相同”的要求。本题请你根据要求，自动填充“我出生于y年，直到x岁才遇到n个数字都不相同的年份”这句话。  
输入格式：  
  输入在一行中给出出生年份y和目标年份中不同数字的个数n，其中y在\[1, 3000\]之间，n可以是2、或3、或4。注意不足4位的年份要在前面补零，例如公元1年被认为是0001年，有2个不同的数字0和1。  
输出格式：  
  根据输入，输出x和能达到要求的年份。数字间以1个空格分隔，行首尾不得有多余空格。年份要按4位输出。注意：所谓“n个数字都不相同”是指不同的数字正好是n个。如“2013”被视为满足“4位数字都不同”的条件，但不被视为满足2位或3位数字不同的条件。

输入样例1：  
1988 4  
输出样例1：  
25 2013  
输入样例2：  
1 2  
输出样例2：  
0 0001

---

#### **分析：** {#分析}

计算不相同的数有多少位，可以运用set集合，将数的各个位数扔进set集合中，然后判断n是否等于set集合大小即可。

**注意：**因为y最大为3000，所以当n取最大值4时，最大的4个不同位数的数是3012，所以循环的判断条件临界点为3012。

---

#### **代码：** {#代码}

```cpp
#include<iostream>
#include<cstdio>
#include<set>
#include<string>
#include<stack>

using namespace std;

set<int> s;

int Calulation(int n) {
    int num = 0;
    for(int i = 0; i < 4; ++i) {
        num = n % 10;
        s.insert(num);
        n = n / 10;
    }
    return s.size();
}


int main() {
    int y, n;
    cin >> y >> n;

    for(int i = y; i <= 3012; ++i) {
        if(Calulation(i) == n) {
            cout << i - y << " ";
            printf("%04d\n", i);
            break;
        }
        s.clear();
    }
}
```



