## k倍区间 {#历届试题-k倍区间}

问题描述

给定一个长度为N的数列，A1, A2, ... AN，如果其中一段连续的子序列Ai, Ai+1, ... Aj\(i &lt;= j\)之和是K的倍数，我们就称这个区间\[i, j\]是K倍区间。

你能求出数列中总共有多少个K倍区间吗？

输入格式

第一行包含两个整数N和K。\(1 &lt;= N, K &lt;= 100000\)

以下N行每行包含一个整数Ai。\(1 &lt;= Ai &lt;= 100000\)

输出格式

输出一个整数，代表K倍区间的数目。

样例输入

5 2

1

2

3

4

5

样例输出

6

数据规模和约定

峰值内存消耗（含虚拟机） &lt; 256M　　CPU消耗 &lt; 2000ms

请严格按要求输出，不要画蛇添足地打印类似：“请您输入...” 的多余内容。

---

## 解题思路： {#解题思路：}

求区间\[l,r\]的和是k的倍数的个数。

我们规定sum\[i\]表示第1个元素到第i个元素的和。那么sum\[r\] - sum\[l-1\]就是区间\[l,r\]的和。区间\[l,r\]的和是k的倍数即\(sum\[r\] - sum\[l-1\]\)%k == 0 即sum\[r\]%k == sum\[l-1\]%k。那么，我们求出每个前缀和，在求的过程中取模，两个相等的前缀和就能组成一个k倍区间。我们可以在计算完前缀和以后，使用两层for循环来计数k倍区间的个数。但是由于数据量较大，这样是会超时的。那么我们是否能在计算前缀和的过程中来记录k倍区间的个数呢？

我们用一个数组cnt\[i\]表示当前位置之前，前缀和取模后等于i的个数。举个例子：

数列 1 2 3 4 5 mod = 2

对前1个数的和取模， 为1 之前有0个前缀和取模后为1，个数+0

对前2个数的和取模， 为1 之前有1个前缀和取模后为1，个数+1

对前3个数的和取模， 为0 之前有0个前缀和取模后为0, 个数+0

对前4个数的和取模， 为0 之前有1个前缀和取模后为0，个数+1

对钱5个数的和取模， 为1 之前有2个前缀和取模后为1，个数+2

到目前为止ans = 4。但是ans应该等于6，因为这样计算后，我们漏掉了前i个数的和取模是k的倍数的情况，即\[0,i\]区间和是k的倍数，因此，我们要在ans = 4 的基础上 加上前缀和取模后为0的个数 即ans+2 = 6;

---

## AC代码： {#ac代码：}

```cpp
#include <algorithm>
#include <string.h>
#include <iostream>
#include <stdio.h>
#include <string>
#include <vector>
#include <queue>
#include <map>
#include <set>

using namespace std;

int sum[100000 + 10];
int cnt[100000 + 10];
long long ans;
int num;

int main() {

    ios::sync_with_stdio(false);

    int n, k;
    cin >> n >> k;
    for(int i = 1; i <= n; ++i) {
        cin >> num;
        sum[i] = (sum[i - 1] + num) % k;
        ans += cnt[sum[i]];
        cnt[sum[i]]++;
    }    
    cout << ans + cnt[0] << endl;
    return 0;
}
```



